<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://agentplexus.github.io/go-opik/tutorials/agentic-observability/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Agentic Observability - Go Opik SDK</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Agentic Observability";
        var mkdocs_page_input_path = "tutorials/agentic-observability.md";
        var mkdocs_page_url = "/go-opik/tutorials/agentic-observability/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Go Opik SDK
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Getting Started</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting-started/installation/">Installation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting-started/configuration/">Configuration</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting-started/testing/">Testing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting-started/development/">Development</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Core Concepts</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../core-concepts/traces-and-spans/">Traces and Spans</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../core-concepts/context-propagation/">Context Propagation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../core-concepts/feedback-scores/">Feedback Scores</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Features</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../features/datasets/">Datasets</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../features/experiments/">Experiments</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../features/prompts/">Prompts</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../features/streaming/">Streaming</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../features/batching/">Batching</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Evaluation</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../evaluation/overview/">Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../evaluation/heuristic-metrics/">Heuristic Metrics</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../evaluation/llm-judges/">LLM Judges</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Integrations</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../integrations/openai/">OpenAI</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../integrations/anthropic/">Anthropic</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../integrations/omnillm/">omnillm</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../integrations/http-middleware/">HTTP Middleware</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Agentic Observability</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#case-study-stats-agent-team">Case Study: Stats Agent Team</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part-1-integrating-with-google-adk-agents">Part 1: Integrating with Google ADK Agents</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#11-basic-adk-agent-structure">1.1 Basic ADK Agent Structure</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#12-adding-opik-tracing-to-adk-agents">1.2 Adding Opik Tracing to ADK Agents</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#13-tracing-tool-invocations">1.3 Tracing Tool Invocations</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part-2-integrating-with-eino-workflow-graphs">Part 2: Integrating with Eino Workflow Graphs</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#21-basic-eino-graph-structure">2.1 Basic Eino Graph Structure</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22-adding-opik-tracing-to-eino-workflows">2.2 Adding Opik Tracing to Eino Workflows</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23-tracing-individual-eino-nodes">2.3 Tracing Individual Eino Nodes</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part-3-complete-integration-example">Part 3: Complete Integration Example</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#part-4-viewing-traces-in-opik-dashboard">Part 4: Viewing Traces in Opik Dashboard</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#trace-hierarchy">Trace Hierarchy</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#key-metrics-to-monitor">Key Metrics to Monitor</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#best-practices">Best Practices</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-use-meaningful-span-names">1. Use Meaningful Span Names</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-capture-relevant-inputsoutputs">2. Capture Relevant Inputs/Outputs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-add-structured-feedback-scores">3. Add Structured Feedback Scores</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4-use-tags-for-filtering">4. Use Tags for Filtering</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#next-steps">Next Steps</a>
    </li>
    </ul>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../cli/">CLI Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../api-reference/">API Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../presentation.html">Presentation</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Go Opik SDK</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Tutorials</li>
      <li class="breadcrumb-item active">Agentic Observability</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/agentplexus/go-opik/edit/master/docs/tutorials/agentic-observability.md">Edit on agentplexus/go-opik</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="agentic-observability-integrating-opik-with-google-adk-and-eino">Agentic Observability: Integrating Opik with Google ADK and Eino<a class="headerlink" href="#agentic-observability-integrating-opik-with-google-adk-and-eino" title="Permanent link">&para;</a></h1>
<p>This tutorial demonstrates how to add LLM observability to agentic Go applications using the go-opik SDK. We'll use a real-world case study based on the <a href="https://github.com/agentplexus/stats-agent-team">stats-agent-team</a> project, which implements a multi-agent system for statistics research and verification.</p>
<h2 id="overview">Overview<a class="headerlink" href="#overview" title="Permanent link">&para;</a></h2>
<p>Modern AI applications increasingly use agentic architectures where multiple specialized agents collaborate to complete complex tasks. Observability is critical for:</p>
<ul>
<li><strong>Debugging</strong>: Understanding why an agent made a particular decision</li>
<li><strong>Performance</strong>: Identifying bottlenecks in multi-agent workflows</li>
<li><strong>Cost tracking</strong>: Monitoring LLM token usage across agents</li>
<li><strong>Quality assurance</strong>: Evaluating agent outputs over time</li>
</ul>
<p>This tutorial covers integration with two popular Go agent frameworks:</p>
<ol>
<li><strong>Google Agent Development Kit (ADK)</strong> - A framework for building LLM-powered agents with tools</li>
<li><strong>Eino</strong> - CloudWeGo's framework for building deterministic agent workflows as graphs</li>
</ol>
<h2 id="case-study-stats-agent-team">Case Study: Stats Agent Team<a class="headerlink" href="#case-study-stats-agent-team" title="Permanent link">&para;</a></h2>
<p>The stats-agent-team project implements a 4-agent system for researching and verifying statistics:</p>
<pre><code>┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Research Agent │ ──▶ │ Synthesis Agent │ ──▶ │Verification Agent│ ──▶ │  Orchestrator   │
│  (Web Search)   │     │   (LLM + ADK)   │     │    (LLM + ADK)   │     │  (Eino Graph)   │
└─────────────────┘     └─────────────────┘     └─────────────────┘     └─────────────────┘
</code></pre>
<ul>
<li><strong>Research Agent</strong>: Finds relevant sources using web search APIs</li>
<li><strong>Synthesis Agent</strong>: Extracts statistics from web pages using LLM (Google ADK)</li>
<li><strong>Verification Agent</strong>: Verifies extracted statistics against sources (Google ADK)</li>
<li><strong>Orchestrator</strong>: Coordinates the workflow using Eino's graph-based approach</li>
</ul>
<h2 id="part-1-integrating-with-google-adk-agents">Part 1: Integrating with Google ADK Agents<a class="headerlink" href="#part-1-integrating-with-google-adk-agents" title="Permanent link">&para;</a></h2>
<p>Google ADK provides a structured way to build agents with tools. Here's how to add Opik observability.</p>
<h3 id="11-basic-adk-agent-structure">1.1 Basic ADK Agent Structure<a class="headerlink" href="#11-basic-adk-agent-structure" title="Permanent link">&para;</a></h3>
<p>The Synthesis Agent uses ADK's <code>llmagent</code> and <code>functiontool</code> packages:</p>
<pre><code class="language-go">import (
    &quot;google.golang.org/adk/agent&quot;
    &quot;google.golang.org/adk/agent/llmagent&quot;
    &quot;google.golang.org/adk/model&quot;
    &quot;google.golang.org/adk/tool&quot;
    &quot;google.golang.org/adk/tool/functiontool&quot;
)

type SynthesisAgent struct {
    model    model.LLM
    adkAgent agent.Agent
}

func NewSynthesisAgent(llmModel model.LLM) (*SynthesisAgent, error) {
    sa := &amp;SynthesisAgent{model: llmModel}

    // Create a tool for statistics extraction
    synthesisTool, err := functiontool.New(functiontool.Config{
        Name:        &quot;synthesize_statistics&quot;,
        Description: &quot;Extracts numerical statistics from web page content&quot;,
    }, sa.synthesisToolHandler)
    if err != nil {
        return nil, err
    }

    // Create the ADK agent
    adkAgent, err := llmagent.New(llmagent.Config{
        Name:        &quot;statistics_synthesis_agent&quot;,
        Model:       llmModel,
        Description: &quot;Extracts statistics from web content&quot;,
        Instruction: &quot;You are a statistics extraction expert...&quot;,
        Tools:       []tool.Tool{synthesisTool},
    })
    if err != nil {
        return nil, err
    }

    sa.adkAgent = adkAgent
    return sa, nil
}
</code></pre>
<h3 id="12-adding-opik-tracing-to-adk-agents">1.2 Adding Opik Tracing to ADK Agents<a class="headerlink" href="#12-adding-opik-tracing-to-adk-agents" title="Permanent link">&para;</a></h3>
<p>Wrap your ADK agent's LLM calls with Opik traces:</p>
<pre><code class="language-go">import (
    opik &quot;github.com/agentplexus/go-opik&quot;
)

type TracedSynthesisAgent struct {
    *SynthesisAgent
    opikClient *opik.Client
}

func NewTracedSynthesisAgent(llmModel model.LLM) (*TracedSynthesisAgent, error) {
    // Create base agent
    base, err := NewSynthesisAgent(llmModel)
    if err != nil {
        return nil, err
    }

    // Create Opik client
    opikClient, err := opik.NewClient(
        opik.WithProjectName(&quot;stats-agent-team&quot;),
    )
    if err != nil {
        return nil, err
    }

    return &amp;TracedSynthesisAgent{
        SynthesisAgent: base,
        opikClient:     opikClient,
    }, nil
}

func (tsa *TracedSynthesisAgent) ExtractStatistics(ctx context.Context, topic string, content string) ([]Statistic, error) {
    // Create a trace for this extraction operation
    trace, err := tsa.opikClient.Trace(ctx, &quot;extract-statistics&quot;,
        opik.WithTraceInput(map[string]any{
            &quot;topic&quot;:          topic,
            &quot;content_length&quot;: len(content),
        }),
        opik.WithTraceTags(&quot;agent:synthesis&quot;, &quot;operation:extraction&quot;),
    )
    if err != nil {
        return nil, err
    }
    defer trace.End(ctx)

    // Create a span for the LLM call
    span, err := trace.Span(ctx, &quot;llm-extraction&quot;,
        opik.WithSpanType(opik.SpanTypeLLM),
        opik.WithSpanModel(&quot;gemini-2.0-flash-exp&quot;),
        opik.WithSpanProvider(&quot;google&quot;),
        opik.WithSpanInput(map[string]any{
            &quot;prompt_template&quot;: &quot;statistics_extraction&quot;,
            &quot;topic&quot;:           topic,
        }),
    )
    if err != nil {
        return nil, err
    }

    // Make the actual LLM call
    stats, err := tsa.doExtraction(ctx, topic, content)

    // End span with output and token usage
    span.End(ctx,
        opik.WithSpanOutput(map[string]any{
            &quot;statistics_count&quot;: len(stats),
            &quot;statistics&quot;:       stats,
        }),
        opik.WithSpanUsage(opik.Usage{
            PromptTokens:     estimateTokens(content),
            CompletionTokens: estimateTokens(formatStats(stats)),
        }),
    )

    if err != nil {
        // Add error feedback
        span.AddFeedbackScore(ctx, &quot;error&quot;, 0, err.Error())
        return nil, err
    }

    // Add quality feedback
    span.AddFeedbackScore(ctx, &quot;extraction_quality&quot;,
        float64(len(stats))/10.0, // Normalize to 0-1
        fmt.Sprintf(&quot;Extracted %d statistics&quot;, len(stats)),
    )

    // Update trace output
    trace.End(ctx, opik.WithTraceOutput(map[string]any{
        &quot;total_statistics&quot;: len(stats),
        &quot;success&quot;:          true,
    }))

    return stats, nil
}
</code></pre>
<h3 id="13-tracing-tool-invocations">1.3 Tracing Tool Invocations<a class="headerlink" href="#13-tracing-tool-invocations" title="Permanent link">&para;</a></h3>
<p>When ADK agents invoke tools, trace each tool call as a separate span:</p>
<pre><code class="language-go">func (tsa *TracedSynthesisAgent) synthesisToolHandler(ctx tool.Context, input SynthesisInput) (SynthesisOutput, error) {
    // Get parent trace from context (set by orchestrator)
    parentTrace := opik.TraceFromContext(ctx)

    // Create a span for this tool invocation
    span, err := parentTrace.Span(ctx, &quot;tool:synthesize_statistics&quot;,
        opik.WithSpanType(opik.SpanTypeTool),
        opik.WithSpanInput(map[string]any{
            &quot;topic&quot;:         input.Topic,
            &quot;url_count&quot;:     len(input.SearchResults),
            &quot;min_stats&quot;:     input.MinStatistics,
            &quot;max_stats&quot;:     input.MaxStatistics,
        }),
    )
    if err != nil {
        return SynthesisOutput{}, err
    }
    defer span.End(ctx)

    // Process each URL with its own span
    var candidates []CandidateStatistic
    for i, result := range input.SearchResults {
        urlSpan, _ := span.Span(ctx, fmt.Sprintf(&quot;process-url-%d&quot;, i),
            opik.WithSpanType(opik.SpanTypeGeneral),
            opik.WithSpanInput(map[string]any{
                &quot;url&quot;:    result.URL,
                &quot;domain&quot;: result.Domain,
            }),
        )

        stats, err := tsa.processURL(ctx, input.Topic, result)

        urlSpan.End(ctx, opik.WithSpanOutput(map[string]any{
            &quot;stats_extracted&quot;: len(stats),
            &quot;error&quot;:           err != nil,
        }))

        if err == nil {
            candidates = append(candidates, stats...)
        }
    }

    span.End(ctx, opik.WithSpanOutput(map[string]any{
        &quot;total_candidates&quot;: len(candidates),
    }))

    return SynthesisOutput{Candidates: candidates}, nil
}
</code></pre>
<h2 id="part-2-integrating-with-eino-workflow-graphs">Part 2: Integrating with Eino Workflow Graphs<a class="headerlink" href="#part-2-integrating-with-eino-workflow-graphs" title="Permanent link">&para;</a></h2>
<p>Eino provides a graph-based approach to building agent workflows. Each node in the graph can be traced.</p>
<h3 id="21-basic-eino-graph-structure">2.1 Basic Eino Graph Structure<a class="headerlink" href="#21-basic-eino-graph-structure" title="Permanent link">&para;</a></h3>
<p>The Orchestrator uses Eino's <code>compose</code> package to build a workflow:</p>
<pre><code class="language-go">import (
    &quot;github.com/cloudwego/eino/compose&quot;
)

type EinoOrchestrator struct {
    graph *compose.Graph[*OrchestrationRequest, *OrchestrationResponse]
}

func NewEinoOrchestrator() *EinoOrchestrator {
    eo := &amp;EinoOrchestrator{}
    eo.graph = eo.buildWorkflowGraph()
    return eo
}

func (eo *EinoOrchestrator) buildWorkflowGraph() *compose.Graph[*OrchestrationRequest, *OrchestrationResponse] {
    g := compose.NewGraph[*OrchestrationRequest, *OrchestrationResponse]()

    // Define nodes
    const (
        nodeValidate     = &quot;validate&quot;
        nodeResearch     = &quot;research&quot;
        nodeSynthesis    = &quot;synthesis&quot;
        nodeVerification = &quot;verification&quot;
        nodeFormat       = &quot;format&quot;
    )

    // Add lambda nodes
    g.AddLambdaNode(nodeValidate, compose.InvokableLambda(eo.validateInput))
    g.AddLambdaNode(nodeResearch, compose.InvokableLambda(eo.callResearch))
    g.AddLambdaNode(nodeSynthesis, compose.InvokableLambda(eo.callSynthesis))
    g.AddLambdaNode(nodeVerification, compose.InvokableLambda(eo.callVerification))
    g.AddLambdaNode(nodeFormat, compose.InvokableLambda(eo.formatResponse))

    // Define edges
    g.AddEdge(compose.START, nodeValidate)
    g.AddEdge(nodeValidate, nodeResearch)
    g.AddEdge(nodeResearch, nodeSynthesis)
    g.AddEdge(nodeSynthesis, nodeVerification)
    g.AddEdge(nodeVerification, nodeFormat)
    g.AddEdge(nodeFormat, compose.END)

    return g
}
</code></pre>
<h3 id="22-adding-opik-tracing-to-eino-workflows">2.2 Adding Opik Tracing to Eino Workflows<a class="headerlink" href="#22-adding-opik-tracing-to-eino-workflows" title="Permanent link">&para;</a></h3>
<p>Trace the entire workflow and each node:</p>
<pre><code class="language-go">type TracedEinoOrchestrator struct {
    *EinoOrchestrator
    opikClient *opik.Client
}

func NewTracedEinoOrchestrator() (*TracedEinoOrchestrator, error) {
    opikClient, err := opik.NewClient(
        opik.WithProjectName(&quot;stats-agent-team&quot;),
    )
    if err != nil {
        return nil, err
    }

    return &amp;TracedEinoOrchestrator{
        EinoOrchestrator: NewEinoOrchestrator(),
        opikClient:       opikClient,
    }, nil
}

func (teo *TracedEinoOrchestrator) Orchestrate(ctx context.Context, req *OrchestrationRequest) (*OrchestrationResponse, error) {
    // Create a trace for the entire workflow
    trace, err := teo.opikClient.Trace(ctx, &quot;eino-orchestration&quot;,
        opik.WithTraceInput(map[string]any{
            &quot;topic&quot;:              req.Topic,
            &quot;min_verified_stats&quot;: req.MinVerifiedStats,
            &quot;max_candidates&quot;:     req.MaxCandidates,
        }),
        opik.WithTraceTags(&quot;framework:eino&quot;, &quot;workflow:orchestration&quot;),
    )
    if err != nil {
        return nil, err
    }

    // Store trace in context for child spans
    ctx = opik.ContextWithTrace(ctx, trace)

    // Compile and execute the graph
    compiled, err := teo.graph.Compile(ctx)
    if err != nil {
        trace.End(ctx, opik.WithTraceOutput(map[string]any{
            &quot;error&quot;: err.Error(),
        }))
        return nil, err
    }

    result, err := compiled.Invoke(ctx, req)

    // End trace with final results
    if err != nil {
        trace.End(ctx, opik.WithTraceOutput(map[string]any{
            &quot;error&quot;:   err.Error(),
            &quot;success&quot;: false,
        }))
        return nil, err
    }

    trace.End(ctx, opik.WithTraceOutput(map[string]any{
        &quot;success&quot;:          true,
        &quot;verified_count&quot;:   result.VerifiedCount,
        &quot;total_candidates&quot;: result.TotalCandidates,
        &quot;failed_count&quot;:     result.FailedCount,
    }))

    // Add workflow quality score
    qualityScore := float64(result.VerifiedCount) / float64(req.MinVerifiedStats)
    if qualityScore &gt; 1.0 {
        qualityScore = 1.0
    }
    trace.AddFeedbackScore(ctx, &quot;workflow_quality&quot;, qualityScore,
        fmt.Sprintf(&quot;Verified %d/%d statistics&quot;, result.VerifiedCount, req.MinVerifiedStats))

    return result, nil
}
</code></pre>
<h3 id="23-tracing-individual-eino-nodes">2.3 Tracing Individual Eino Nodes<a class="headerlink" href="#23-tracing-individual-eino-nodes" title="Permanent link">&para;</a></h3>
<p>Create spans for each node in the workflow:</p>
<pre><code class="language-go">func (teo *TracedEinoOrchestrator) callResearch(ctx context.Context, req *OrchestrationRequest) (*ResearchState, error) {
    // Get trace from context
    trace := opik.TraceFromContext(ctx)

    // Create span for this node
    span, _ := trace.Span(ctx, &quot;eino-node:research&quot;,
        opik.WithSpanType(opik.SpanTypeGeneral),
        opik.WithSpanInput(map[string]any{
            &quot;topic&quot;:       req.Topic,
            &quot;max_results&quot;: req.MaxCandidates,
        }),
        opik.WithSpanMetadata(map[string]any{
            &quot;eino_node&quot;:    &quot;research&quot;,
            &quot;agent_url&quot;:    teo.researchAgentURL,
        }),
    )

    startTime := time.Now()

    // Call the research agent
    resp, err := teo.callResearchAgent(ctx, &amp;ResearchRequest{
        Topic:         req.Topic,
        MaxStatistics: req.MaxCandidates,
    })

    duration := time.Since(startTime)

    if err != nil {
        span.End(ctx, opik.WithSpanOutput(map[string]any{
            &quot;error&quot;:    err.Error(),
            &quot;duration&quot;: duration.String(),
        }))
        return nil, err
    }

    span.End(ctx, opik.WithSpanOutput(map[string]any{
        &quot;sources_found&quot;: len(resp.Candidates),
        &quot;duration&quot;:      duration.String(),
    }))

    return &amp;ResearchState{
        Request:       req,
        SearchResults: convertToSearchResults(resp.Candidates),
    }, nil
}

func (teo *TracedEinoOrchestrator) callSynthesis(ctx context.Context, state *ResearchState) (*SynthesisState, error) {
    trace := opik.TraceFromContext(ctx)

    span, _ := trace.Span(ctx, &quot;eino-node:synthesis&quot;,
        opik.WithSpanType(opik.SpanTypeLLM), // LLM-heavy operation
        opik.WithSpanInput(map[string]any{
            &quot;sources_count&quot;: len(state.SearchResults),
            &quot;topic&quot;:         state.Request.Topic,
        }),
    )

    resp, err := teo.callSynthesisAgent(ctx, &amp;SynthesisRequest{
        Topic:         state.Request.Topic,
        SearchResults: state.SearchResults,
    })

    if err != nil {
        span.End(ctx, opik.WithSpanOutput(map[string]any{&quot;error&quot;: err.Error()}))
        return nil, err
    }

    span.End(ctx, opik.WithSpanOutput(map[string]any{
        &quot;candidates_extracted&quot;: len(resp.Candidates),
    }))

    return &amp;SynthesisState{
        Request:    state.Request,
        Candidates: resp.Candidates,
    }, nil
}
</code></pre>
<h2 id="part-3-complete-integration-example">Part 3: Complete Integration Example<a class="headerlink" href="#part-3-complete-integration-example" title="Permanent link">&para;</a></h2>
<p>Here's a complete example combining ADK agents with Eino orchestration and full Opik tracing:</p>
<pre><code class="language-go">package main

import (
    &quot;context&quot;
    &quot;log&quot;

    opik &quot;github.com/agentplexus/go-opik&quot;
)

func main() {
    // Initialize Opik client
    opikClient, err := opik.NewClient(
        opik.WithProjectName(&quot;stats-agent-team&quot;),
        opik.WithAPIKey(os.Getenv(&quot;OPIK_API_KEY&quot;)),
        opik.WithWorkspace(os.Getenv(&quot;OPIK_WORKSPACE&quot;)),
    )
    if err != nil {
        log.Fatalf(&quot;Failed to create Opik client: %v&quot;, err)
    }

    // Create the orchestrator with tracing
    orchestrator := NewTracedOrchestrator(opikClient)

    // Execute a research request
    ctx := context.Background()
    result, err := orchestrator.Research(ctx, &amp;OrchestrationRequest{
        Topic:            &quot;climate change statistics 2024&quot;,
        MinVerifiedStats: 10,
        MaxCandidates:    30,
    })

    if err != nil {
        log.Fatalf(&quot;Research failed: %v&quot;, err)
    }

    log.Printf(&quot;Research complete: %d verified statistics&quot;, result.VerifiedCount)
}

type TracedOrchestrator struct {
    opikClient  *opik.Client
    eino        *EinoOrchestrator
    synthesis   *SynthesisAgent
    verification *VerificationAgent
}

func (to *TracedOrchestrator) Research(ctx context.Context, req *OrchestrationRequest) (*OrchestrationResponse, error) {
    // Create main trace
    trace, _ := to.opikClient.Trace(ctx, &quot;full-research-workflow&quot;,
        opik.WithTraceInput(map[string]any{
            &quot;topic&quot;:     req.Topic,
            &quot;min_stats&quot;: req.MinVerifiedStats,
        }),
        opik.WithTraceTags(&quot;workflow:research&quot;, &quot;version:v1&quot;),
    )
    defer trace.End(ctx)

    // Store in context
    ctx = opik.ContextWithTrace(ctx, trace)

    // Execute Eino workflow (which creates child spans)
    result, err := to.eino.Orchestrate(ctx, req)

    // Add evaluation scores
    if err == nil {
        // Calculate quality metrics
        accuracyScore := float64(result.VerifiedCount) / float64(result.TotalCandidates)
        coverageScore := float64(result.VerifiedCount) / float64(req.MinVerifiedStats)
        if coverageScore &gt; 1.0 {
            coverageScore = 1.0
        }

        trace.AddFeedbackScore(ctx, &quot;accuracy&quot;, accuracyScore, &quot;Verification accuracy&quot;)
        trace.AddFeedbackScore(ctx, &quot;coverage&quot;, coverageScore, &quot;Target coverage&quot;)
    }

    return result, err
}
</code></pre>
<h2 id="part-4-viewing-traces-in-opik-dashboard">Part 4: Viewing Traces in Opik Dashboard<a class="headerlink" href="#part-4-viewing-traces-in-opik-dashboard" title="Permanent link">&para;</a></h2>
<p>After running your agents with tracing enabled, you can view the traces in the Opik dashboard:</p>
<h3 id="trace-hierarchy">Trace Hierarchy<a class="headerlink" href="#trace-hierarchy" title="Permanent link">&para;</a></h3>
<pre><code>full-research-workflow (trace)
├── eino-node:validate (span)
├── eino-node:research (span)
│   └── http-call:research-agent (span)
├── eino-node:synthesis (span)
│   ├── llm-extraction (span, type=llm)
│   ├── process-url-0 (span)
│   │   └── llm-call (span, type=llm)
│   ├── process-url-1 (span)
│   │   └── llm-call (span, type=llm)
│   └── ... more URLs
├── eino-node:verification (span)
│   ├── verify-stat-0 (span, type=llm)
│   ├── verify-stat-1 (span, type=llm)
│   └── ... more verifications
└── eino-node:format (span)
</code></pre>
<h3 id="key-metrics-to-monitor">Key Metrics to Monitor<a class="headerlink" href="#key-metrics-to-monitor" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Latency</strong>: Total workflow time and per-node breakdown</li>
<li><strong>Token Usage</strong>: LLM tokens per agent and total</li>
<li><strong>Success Rate</strong>: Verification success rate over time</li>
<li><strong>Quality Scores</strong>: Accuracy and coverage metrics</li>
</ol>
<h2 id="best-practices">Best Practices<a class="headerlink" href="#best-practices" title="Permanent link">&para;</a></h2>
<h3 id="1-use-meaningful-span-names">1. Use Meaningful Span Names<a class="headerlink" href="#1-use-meaningful-span-names" title="Permanent link">&para;</a></h3>
<pre><code class="language-go">// Good: Descriptive and hierarchical
span, _ := trace.Span(ctx, &quot;synthesis:extract-from-url&quot;,
    opik.WithSpanMetadata(map[string]any{
        &quot;url_index&quot;: i,
        &quot;domain&quot;:    result.Domain,
    }),
)

// Avoid: Generic names
span, _ := trace.Span(ctx, &quot;process&quot;) // Too vague
</code></pre>
<h3 id="2-capture-relevant-inputsoutputs">2. Capture Relevant Inputs/Outputs<a class="headerlink" href="#2-capture-relevant-inputsoutputs" title="Permanent link">&para;</a></h3>
<pre><code class="language-go">// Capture enough context for debugging
span, _ := trace.Span(ctx, &quot;llm-extraction&quot;,
    opik.WithSpanInput(map[string]any{
        &quot;topic&quot;:          topic,
        &quot;content_length&quot;: len(content),
        &quot;content_hash&quot;:   hashContent(content), // For deduplication
    }),
)

span.End(ctx, opik.WithSpanOutput(map[string]any{
    &quot;stats_count&quot;: len(stats),
    &quot;stats&quot;:       stats, // Full output for analysis
}))
</code></pre>
<h3 id="3-add-structured-feedback-scores">3. Add Structured Feedback Scores<a class="headerlink" href="#3-add-structured-feedback-scores" title="Permanent link">&para;</a></h3>
<pre><code class="language-go">// Quantitative metrics
span.AddFeedbackScore(ctx, &quot;extraction_count&quot;, float64(len(stats)), &quot;&quot;)
span.AddFeedbackScore(ctx, &quot;accuracy&quot;, verifiedCount/totalCount, &quot;&quot;)

// Categorical with reason
span.AddFeedbackScore(ctx, &quot;quality&quot;, 0.8, &quot;Good extraction but missing units&quot;)
</code></pre>
<h3 id="4-use-tags-for-filtering">4. Use Tags for Filtering<a class="headerlink" href="#4-use-tags-for-filtering" title="Permanent link">&para;</a></h3>
<pre><code class="language-go">trace, _ := opikClient.Trace(ctx, &quot;workflow&quot;,
    opik.WithTraceTags(
        &quot;env:production&quot;,
        &quot;agent:synthesis&quot;,
        &quot;llm:gemini-2.0-flash&quot;,
        &quot;topic:climate&quot;,
    ),
)
</code></pre>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>Integrating Opik with Google ADK and Eino provides comprehensive observability for agentic applications:</p>
<ul>
<li><strong>ADK Integration</strong>: Trace tool invocations and LLM calls within agents</li>
<li><strong>Eino Integration</strong>: Trace workflow nodes and graph execution</li>
<li><strong>Combined</strong>: Full visibility into multi-agent orchestration</li>
</ul>
<p>This enables you to debug issues, optimize performance, track costs, and improve agent quality over time.</p>
<h2 id="next-steps">Next Steps<a class="headerlink" href="#next-steps" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="../evaluation/metrics.md">Evaluation Metrics</a> - Use Opik's evaluation system to automatically score agent outputs</li>
<li><a href="../../integrations/openai/">LLM Provider Integrations</a> - Direct integration with OpenAI, Anthropic, and other providers</li>
<li><a href="../../features/datasets/">Datasets and Experiments</a> - Run experiments to compare agent configurations</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../integrations/http-middleware/" class="btn btn-neutral float-left" title="HTTP Middleware"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../cli/" class="btn btn-neutral float-right" title="CLI Reference">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/agentplexus/go-opik" class="fa fa-code-fork" style="color: #fcfcfc"> agentplexus/go-opik</a>
        </span>
    
    
      <span><a href="../../integrations/http-middleware/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../cli/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
